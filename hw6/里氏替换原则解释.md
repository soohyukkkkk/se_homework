# 里氏替换原则Liskov Substitution Principle

## 定义：
所有引用基类的地方必须能透明地使用其子类的对象。所有基类在的地方，都可以换成子类，程序还可以正常运行。这个原则是与面向对象语言的 继承 特性密切相关的。

## 解释说明
由于面向对象语言的继承特性，子类拥有父类的所有方法，因此，将基类替换成具体的子类，子类也可以调用父类中的方法（其实是它自己的方法，继承于父类），但是如果要保证完全可以调用，光名称相同不行，还需要满足下面两个条件：
1. 子类中的方法的前置条件必须与超类中被覆写的方法的前置条件相同或更宽松。
2. 子类中的方法的后置条件必须与超类中被覆写的方法的后置条件相同或更严格。
这样的话，调用就没有问题了。否则，我在父类中传入一个 List 类型的参数，子类中重写的方法参数却变为 ArrayList ，那客户端使用的时候传入一个 LinkedList 类型的参数，使用父类的时候程序正常运行，但根据 LSP 原则，替换成子类后程序就会出现问题。同理，后置条件也是如此。


## 举例：
首先有一个父类，水果类：
```
public class Fruit {
    void introduce() {
        System.out.println("我是水果父类...");
    }
}
```
其次，它有一个子类，苹果类：
```
public class Apple extends Fruit {
    @Override
    void introduce() {
        System.out.println("我是水果子类——苹果");
    }
}
```
客户端代码如下：
```
public static void main(String[] args) {
    Fruit fruit = new Fruit();
    HashMap map = new HashMap<>();
    fruit.introduce();
}
```
运行结果：

我是水果父类...
1
那么，如果按照 LSP 原则，所有父类出现的地方都能换成其子类，代码如下：
```
public static void main(String[] args) {
    Apple fruit = new Apple();
    HashMap map = new HashMap<>();
    fruit.introduce();
}
```
那么运行结果就会变成：

我是水果子类——苹果

与原来的输出不同，程序的功能被改变了，违背了 LSP 原则。

因此，可以看到， LSP 原则最重要的一点就是：避免子类重写父类中已经实现的方法。这就是 LSP 原则的本质。这里由于 Fruit 父类已经实现了 introduce 方法，因此子类应该避免再对其进行重写，如果需要增加个性化，就应该对父类进行扩展，而不是重写，否则也会违背开闭原则。

一般来讲，程序中父类大多是抽象类，因为父类只是一个框架，具体功能还需要子类来实现。因此很少直接去 new 一个父类。而如果出现这种情况，那么就说明父类中实现的代码已经很好了，子类只需要对其进行扩展就会，尽量避免对其已经实现的方法再去重写。
